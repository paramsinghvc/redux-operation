{"version":3,"sources":["augmentReducer.ts","index.ts"],"names":[],"mappings":";AAEa,aAAA,QAAA,YAAA,EAAA,QAAA,eAAiB,SAC1B,GACC,OAAA,SAAC,GACK,OAAA,SAAC,EAAU,GACR,IAAA,EAAY,GACZ,EAAgB,EAAY,EAAO,GACzC,OAAO,OAAO,EAAW,GACI,IAAA,IAAA,EAAA,EAAA,EAAA,OAAO,QAAQ,GAAf,EAAA,EAAA,OAAA,IAA0B,CAA5C,IAAA,EAAA,EAAA,GAAC,EAAA,EAAA,GAAK,EAAA,EAAA,GACT,GAAA,EAAO,CACD,IAAA,EAAkB,EAAQ,EAAM,GAAM,GAC5C,EAAU,GAAO,GAGlB,OAAA;;;;ACgFf,aAAA,IAAA,EAAA,MAAA,KAAA,UAAA,WAAA,OAAA,EAAA,OAAA,QAAA,SAAA,GAAA,IAAA,IAAA,EAAA,EAAA,EAAA,EAAA,UAAA,OAAA,EAAA,EAAA,IAAA,IAAA,IAAA,KAAA,EAAA,UAAA,GAAA,OAAA,UAAA,eAAA,KAAA,EAAA,KAAA,EAAA,GAAA,EAAA,IAAA,OAAA,IAAA,MAAA,KAAA,YAAA,SAAA,EAAA,GAAA,IAAA,IAAA,KAAA,EAAA,QAAA,eAAA,KAAA,QAAA,GAAA,EAAA,IAAA,QAAA,YAAA,EA7FA,EAAA,QAAA,qBACA,EAAA,QAAA,YAEa,QAAA,wBAAgE,SAIzE,GACC,OAAA,SAAC,GAAgC,MAAA,CAClC,KAAI,EACJ,QAAO,KAWE,QAAA,sBAAwB,SAAC,GAClC,OAAA,EAAU,OAAO,SAAC,EAA0B,GACjC,IAAA,EAAA,EAAA,GAAK,EAAA,EAAA,GAEL,OADP,EAAa,IAAI,EAAK,OAAO,IACtB,GACR,IAAI,MAGX,IASY,EATN,EAAY,KASlB,SAAY,GACR,EAAA,QAAA,UACA,EAAA,QAAA,UACA,EAAA,QAAA,UAHJ,CAAY,EAAA,QAAA,cAAA,QAAA,YAAW,KAMvB,IAAM,EAAuB,SAAC,GAIpB,IAAA,EAAY,QAAA,sBACd,OAAO,OAAO,GAAa,IAAI,SAAC,GAAqB,MAAA,CACjD,EACA,GAAG,EAAa,EAAY,MAO9B,EAAU,OAAO,OAAO,GAAa,IAAI,SAAA,GAC3C,OAAA,QAAA,wBAAyC,EAAU,IAAI,MAGrD,EAAiC,CACnC,SAAS,EACT,SAAS,EACT,SAAS,EACT,OAAQ,MAoBL,MAAA,CACH,UAAS,EACT,QAAO,EACP,QAfY,SAAC,EAAsB,QAAtB,IAAA,IAAA,EAAA,GAAwB,IAAA,EAAA,EAAA,KAAM,EAAA,EAAA,QAAA,OAAA,IAAA,OAAA,EAAA,EACnC,OAAA,GACC,KAAA,EAAU,IAAI,EAAY,SAC3B,OAAA,EAAA,GAAY,EAAY,CAAE,SAAS,IAClC,KAAA,EAAU,IAAI,EAAY,SAC3B,OAAA,EAAA,GAAY,EAAY,CAAE,SAAS,IAClC,KAAA,EAAU,IAAI,EAAY,SAC3B,OAAA,EAAA,GAAY,EAAY,CAAE,SAAS,EAAM,OAAQ,IACrD,QACW,OAAA,MAUvB,QAAA,QAAe","file":"index.js","sourceRoot":"../src","sourcesContent":["import { IAction, IReducer } from './types';\n\nexport const augmentReducer = <S, A extends IAction<Symbol | string, any>>(\n    rootReducer: IReducer<any, A>\n) => (reducers: { [k: string]: IReducer<any, A> }) => {\n    return (state: S, action: A) => {\n        const nextState = {};\n        const nextRootState = rootReducer(state, action);\n        Object.assign(nextState, nextRootState);\n        for (const [key, reducer] of Object.entries(reducers)) {\n            if (state) {\n                const nextStateForKey = reducer(state[key], action);\n                nextState[key] = nextStateForKey;\n            }\n        }\n        return nextState;\n    };\n};\n","import { IConstants, IAction, IActionCreator } from './types';\n\nexport * from './augmentReducer';\nexport * from './types';\n\nexport const createActionWithPayload: IActionCreator<Symbol | string, any> = <\n    T extends Symbol | string,\n    P\n>(\n    type: T\n) => (payload?: P): IAction<T, P> => ({\n    type,\n    payload\n});\n\n/**\n * Outputs a Map of string as keys and Symbol | strings as it's values. For eg\n * {\n *    foo: Symbol('bar'),\n *    baz: Symbol('bax'),\n * }\n * @param constants [['foo', 'bar'], ['baz', 'bax']]\n */\nexport const makeConstantsWithKeys = (constants: string[][]): IConstants =>\n    constants.reduce((constantsMap: IConstants, constant: string[]) => {\n        const [key, val] = constant;\n        constantsMap.set(key, Symbol(val));\n        return constantsMap;\n    }, new Map<string, Symbol | string>());\n\n\nconst DELIMITER = `_`;\n\nexport interface IReduxOperations {\n    pending: boolean;\n    success: boolean;\n    failure: boolean;\n    errors: any;\n}\n\nexport enum actionFlags {\n    REQUEST = \"REQUEST\",\n    SUCCESS = \"SUCCESS\",\n    FAILURE = \"FAILURE\"\n}\n\nconst createReduxOperation = (actionName: string) => {\n    /**\n     * Will generate constants map in the form of { SUCCESS: Symbol('FETCH_DATA_SUCCESS') }\n     */\n    const constants = makeConstantsWithKeys(\n        Object.values(actionFlags).map((constant: string) => [\n            constant,\n            `${actionName}${DELIMITER}${constant}`\n        ])\n    );\n\n    /**\n     * Generate redux actions for corresponding intents like request, success, failure\n     */\n    const actions = Object.values(actionFlags).map(constant =>\n        createActionWithPayload(<Symbol | string>constants.get(constant))\n    );\n\n    const initialState: IReduxOperations = {\n        pending: false,\n        success: false,\n        failure: false,\n        errors: null\n    };\n\n    /**\n     * Create a reducer to be combined with the original one in the parent context\n     * @param state Redux State holding flags\n     * @param action Redux Action\n     */\n    const reducer = (state = initialState, { type, payload = undefined }) => {\n        switch (type) {\n            case constants.get(actionFlags.REQUEST):\n                return { ...initialState, pending: true };\n            case constants.get(actionFlags.SUCCESS):\n                return { ...initialState, success: true };\n            case constants.get(actionFlags.FAILURE):\n                return { ...initialState, failure: true, errors: payload };\n            default:\n                return state;\n        }\n    };\n    return {\n        constants,\n        actions,\n        reducer\n    };\n};\n\nexport default createReduxOperation;\n"]}